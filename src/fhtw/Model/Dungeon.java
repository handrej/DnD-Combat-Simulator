package fhtw.Model;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.ObjectWriter;
import fhtw.API.Classes;
import fhtw.API.ClassesData;
import fhtw.API.Monsters;
import javafx.scene.image.Image;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.*;

/**
 *
 */
public class Dungeon {
    /**
     * Difficulty rating of enemy encounters. Player Levels are hardcoded to 1 without XP gains.
     * API Difficulty gains 0.25, 0.5, 1, 2, etc. <= 24.
     * Adjusting this value not only makes it harder to traverse but the old json files have to be deleted and ~ more sprite images have to be setup.
     */
    private final static double base_rating = 0.25;
    //private final static double boss_rating = 0.5;
    private static final String imgPath = "src\\fhtw\\Resources\\Sprites\\";

    /**
     * Calculates Ability Scores Modifier
     * @param score Ability Score for str, dex, con, wis, int, cha
     * @return Ability Score Modifier
     */
    public static int as_mod(int score) {
        return (score - 10) / 2;
    }

    @Deprecated
    private int stat_roll() {
        int[] rolls = new int[4];

        int stat = 0;
        for (int i = 0; i < 4; i++) {
            rolls[i] = new Random().nextInt(6) + 1;
            stat += rolls[i];
        }
        int min = rolls[0];
        for (int j : rolls) {
            if (j < min) {
                min = j;
            }
        }
        stat -= min;
        return stat;
    }

    /**
     * Generates random members for the Dungeon party. Pool is hardcoded to reuse class pool for the application (optionally can be fetched into json file) and classes for 5th edition are pretty much set in stone.
     * Main ability scores (Strength, Dexterity, Constitution etc.) scores are randomly generated by throwing a virtual dice four times and adding together the highest values.
     * Other values such as Armor Rating, Health Points, Size of the Hit Die are based on main scores or referenced from class data fetched from <code>dnd5eapi.co</code>
     * @return ArrayList of Characters used for the Adventurer Party
     * @throws IOException API calls verify existence of local json data to reduce network calls
     */
    public static ArrayList<Character> createParty() throws IOException {
        ArrayList<Character> party = new ArrayList<>();
        //List<String> pool_class = new ArrayList<>();
        TreeMap<String, ClassesData> data_class = new TreeMap<>();

        ObjectMapper mapper = new ObjectMapper();
        //Classes api_classes = null;
        String json_file = "src\\fhtw\\Resources\\classes.json";

        File f = new File(json_file);
        if(!f.exists()){
            try {
                f.createNewFile();
            } catch (IOException e) {
                System.err.println("Could not create highscore file.");
            }
        }else{
            data_class = mapper.readValue(f, new TypeReference<TreeMap<String, ClassesData>>() {});
        }

        if (data_class.size() == 0){
            //try {
            //    api_classes = mapper.readValue(new URL("https://www.dnd5eapi.co/api/classes"), Classes.class);
            //} catch (IOException e) {
            //    e.printStackTrace();
            //}
            ClassesData api_classes_data = null;
            for (String classes : Character.class_list) {
                System.out.println(classes);
                try {
                    api_classes_data = mapper.readValue(new URL("https://www.dnd5eapi.co/api/classes/" + classes.toLowerCase()), ClassesData.class);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                //pool_class.add(classes);
                data_class.put(classes, api_classes_data);
            }

            ObjectWriter writer = mapper.writer(new DefaultPrettyPrinter());
            writer.writeValue(f, data_class);
        }

        /*
        TreeMap<String, ArrayList<String>> proficiencies = new TreeMap<>();
        for (Map.Entry<String, ClassesData> classes_info : data_class.entrySet()) {
            ArrayList<String> p = new ArrayList<>();
            for (Map<String, String> tmp : classes_info.getValue().getSaving_throws()) {
                p.add(tmp.get("index"));
            }
            proficiencies.put(classes_info.getKey(), p);
        }*/

        int stat, min;
        int[] rolls = new int[6];
        ArrayList<Integer> stats = new ArrayList<>();
        /*
         * Randomize party members
         * */
        for (int j = 0; j < 4; j++) {
            Character member = new Character();
            //String member_class = pool_class.get(new Random().nextInt(pool_class.size()));
            member.setKlass(Character.class_list.get(new Random().nextInt(Character.class_list.size())));

            for (int k = 0; k < 6; k++) {
                stat = 0;
                for (int i = 0; i < 4; i++) {
                    rolls[i] = new Random().nextInt(6) + 1;
                    stat += rolls[i];
                }
                min = rolls[0];
                for (int l : rolls) {
                    if (l < min) {
                        min = l;
                    }
                }
                stat -= min;
                stats.add(stat);
            }
            //Arrays.sort(stats);
            Collections.sort(stats);

            //for (String prof : proficiencies.get(member.getKlass())){
            for (Map<String, String> prof : data_class.get(member.getKlass()).getSaving_throws()){
                stat = new Random().nextInt(4 + 1 - 3) + 3;
                switch (prof.get("index")) {
                    case "str" -> member.setAs_str(stats.get(stat));
                    case "wis" -> member.setAs_wis(stats.get(stat));
                    case "int" -> member.setAs_int(stats.get(stat));
                    case "con" -> member.setAs_con(stats.get(stat));
                    case "cha" -> member.setAs_cha(stats.get(stat));
                    case "dex" -> member.setAs_dex(stats.get(stat));
                }
                stats.remove(stats.get(stat));
            }

            Collections.shuffle(stats);

            for (Integer val : stats) {
                if (member.getAs_str() == 0){
                    member.setAs_str(val);
                    continue;
                }
                if (member.getAs_wis() == 0) {
                    member.setAs_wis(val);
                    continue;
                }
                if (member.getAs_int() == 0) {
                    member.setAs_int(val);
                    continue;
                }
                if (member.getAs_con() == 0) {
                    member.setAs_con(val);
                    continue;
                }
                if (member.getAs_cha() == 0) {
                    member.setAs_cha(val);
                    continue;
                }
                if (member.getAs_dex() == 0) {
                    member.setAs_dex(val);
                }
            }
            //Hit Die
            member.setHd(data_class.get(member.getKlass()).getHit_die());
            //Health Points
            member.setHp(member.getHd() + as_mod(member.getAs_con()));
            //Armor Class is based on equipment; 12 = light/medium armor type
            member.setAc(12 + as_mod(member.getAs_dex()));
            //member.setBonus_ac(4);
            //make game easier
            member.setBonus(2);
            //map image
            // check if file exists
            member.setImgVal(new Image("file:" + imgPath + member.getKlass().toLowerCase() + ".png", 200, 115, true, true));

            stats.clear();
            party.add(member);
        }
        return party;
    }

    /**
     * Generates a given amount of levels and rooms in the Dungeon. Each level can have an amount of rooms.
     * Amount of rooms determine occurrence of Boss Rooms. Passes along API data to generateEncounters.
     * @param level Amount of level
     * @param rooms Amount of rooms
     * @return Dungeon ArrayList filled with monsters from generateEncounters
     * @throws IOException API calls verify existence of local json data to reduce network calls
     */
    public static ArrayList<ArrayList<ArrayList<Character>>> createDungeon(int level, int rooms) throws IOException {
        //int level = 8, rooms = 4;
        ArrayList<ArrayList<ArrayList<Character>>> dungeon = new ArrayList<>(level);
        List<String> pool_monster = new ArrayList<>();
        TreeMap<String, Monsters> data_monster = new TreeMap<>();

        ObjectMapper mapper = new ObjectMapper();
        Classes api_monsters = null;
        String json_file = "src\\fhtw\\Resources\\monsters.json";

        File f = new File(json_file);
        if (!f.exists()) {
            try {
                f.createNewFile();
            } catch (IOException e) {
                System.err.println("Could not create " + json_file + " file.");
            }
        } else {
            data_monster = mapper.readValue(f, new TypeReference<TreeMap<String, Monsters>>() {
            });
        }

        try {
            api_monsters = mapper.readValue(new URL("https://www.dnd5eapi.co/api/monsters?challenge_rating=" + base_rating), Classes.class);
        } catch (IOException e) {
            e.printStackTrace();
        }
        for (Map<String, String> classes : api_monsters.getResults()) {
            pool_monster.add(classes.get("name"));
        }
        if (data_monster.size() == 0) {
            for (Map<String, String> classes : api_monsters.getResults()) {
                System.out.println("Loading data..." + classes.get("name"));
                Monsters api_monster_data = null;
                try {
                    api_monster_data = mapper.readValue(new URL("https://www.dnd5eapi.co/api/monsters/" + classes.get("index")), Monsters.class);
                } catch (IOException e) {
                    e.printStackTrace();
                }
                //pool_monster.add(classes.get("name"));
                data_monster.put(classes.get("name"), api_monster_data);
            }
            ObjectWriter writer = mapper.writer(new DefaultPrettyPrinter());
            writer.writeValue(f, data_monster);
        }
        //ArrayList<Character> setup = new ArrayList<>();

        for (int i = 0; i <= level; i++) {
            dungeon.add(new ArrayList<>(rooms));
            for (int j = 0; j <= rooms; j++) {
                if (((i % rooms) == 0) && j > 0 && i != 0) continue; // "Boss" Room
                dungeon.get(i).add(generateEncounters(i, j, pool_monster, data_monster));
            }
        }
        return dungeon;
    }

    /**
     * Fill rooms generated by createDungeon with random amount of enemies.
     * Enemy types are randomizes for every encounter and properties are respective to datasheets. Monster sprites found on <code>rpglegion.com</code>
     * @param level Current level in Dungeon ArrayList
     * @param room Current room in Dungeon ArrayList
     * @param pool_monster API data of potential monsters
     * @param data_monster API data of monster properties
     * @return Character ArrayList of enemies
     */
    public static ArrayList<Character> generateEncounters(int level, int room, List<String> pool_monster, TreeMap<String, Monsters> data_monster) {
        ArrayList<Character> setup = new ArrayList<>();

        Random rng = new Random();
        int enemies = rng.nextInt(4) + 1;

        if (level % 4 == 0 && level != 0) {
            enemies = 1;
        }
        for (int i = 0; i < enemies; i++) {
            Character enemy = new Character();
            String current_class = pool_monster.get(new Random().nextInt(pool_monster.size()));
            enemy.setKlass(current_class);
            enemy.setAs_str(data_monster.get(current_class).getStrength());
            enemy.setAs_dex(data_monster.get(current_class).getDexterity());
            enemy.setAs_con(data_monster.get(current_class).getConstitution());
            enemy.setAs_int(data_monster.get(current_class).getIntelligence());
            enemy.setAs_wis(data_monster.get(current_class).getWisdom());
            enemy.setAs_cha(data_monster.get(current_class).getCharisma());
            String hit_die = data_monster.get(current_class).getHit_dice();
            String[] tmp = hit_die.split("d");
            enemy.setHd(Integer.parseInt(tmp[0]) * Integer.parseInt(tmp[1]));
            enemy.setHp(data_monster.get(current_class).getHit_points());
            enemy.setXp(data_monster.get(current_class).getXp());
            enemy.setAc(data_monster.get(current_class).getArmor_class());
            enemy.setImgVal(new Image("file:" + imgPath + current_class.toLowerCase().replace(" ", "") + ".png", 0, 115, true, true));
            setup.add(enemy);
        }
        return setup;
    }
}
